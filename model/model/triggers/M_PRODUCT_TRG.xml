<?xml version="1.0"?>
  <database name="TRIGGER M_PRODUCT_TRG">
    <trigger name="M_PRODUCT_TRG" table="M_PRODUCT" fires="after" insert="true" update="true" delete="true" foreach="row">
      <body><![CDATA[
/*************************************************************************
  * The contents of this file are subject to the Compiere Public
  * License 1.1 ("License"); You may not use this file except in
  * compliance with the License. You may obtain a copy of the License in
  * the legal folder of your Openbravo installation.
  * Software distributed under the License is distributed on an
  * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  * implied. See the License for the specific language governing rights
  * and limitations under the License.
  * The Original Code is  Compiere  ERP &  Business Solution
  * The Initial Developer of the Original Code is Jorg Janke and ComPiere, Inc.
  * Portions created by Jorg Janke are Copyright (C) 1999-2001 Jorg Janke,
  * parts created by ComPiere are Copyright (C) ComPiere, Inc.;
  * All Rights Reserved.
  * Contributor(s): Openbravo SL
  * Contributions are Copyright (C) 2001-2008 Openbravo, S.L.
  *
  * Specifically, this derivative work is based upon the following Compiere
  * file and version.
  *************************************************************************/

   TYPE RECORD IS REF CURSOR;
   Cur_Defaults RECORD;

    v_xTree_ID    varchar2(32);
    v_xParent_ID  varchar2(32);
    v_NextNo      VARCHAR2(32);
    v_ControlNo NUMBER;

    
BEGIN
    
    IF AD_isTriggerEnabled()='N' THEN RETURN;
    END IF;



 IF (UPDATING) THEN
  UPDATE M_PRODUCT_ACCT SET AD_ORG_ID = :new.AD_ORG_ID
  WHERE M_PRODUCT_ID = :new.M_PRODUCT_ID;
 -- Do not allow to de-activate products with OnHand Qty
  IF (:new.IsActive='N' AND :old.IsActive='Y') THEN
   SELECT  COALESCE(SUM(QtyOnHand)+SUM(QtyReserved)*.111+SUM(QtyOrdered)*999, 0) INTO v_ControlNo
   FROM (SELECT QtyOnHand, 0 AS QtyReserved, 0 AS QtyOrdered
   FROM M_Storage_Detail s
   WHERE s.M_Product_ID=:new.M_Product_ID
   UNION
   SELECT 0 AS QtyOnHand, QtyReserved, QtyOrdered
   FROM M_Storage_Pending s
   WHERE s.M_Product_ID=:new.M_Product_ID) A;
   IF (v_ControlNo <> 0) THEN
    RAISE_APPLICATION_ERROR(-20400, 'Product has active Inventory');
   END IF;
  END IF;

  IF( COALESCE(:old.Name,'.') <> COALESCE(:new.Name,'.')
  OR COALESCE(:old.documentnote,'.') <> COALESCE(:new.documentnote,'.') ) THEN
    UPDATE M_PRODUCT_Trl
      SET IsTranslated='N'
    WHERE M_PRODUCT_ID=:new.M_PRODUCT_ID;
  END IF;

  RETURN;
 ELSIF (INSERTING) THEN
  -- For all AcctSchema create ...
  FOR Cur_Defaults IN (
	SELECT  distinct d.*
	FROM  M_Product_Category_Acct d, ad_Org_AcctSchema a
	WHERE  d.M_Product_Category_ID=:new.M_Product_Category_ID
	AND d.C_AcctSchema_ID = a.C_AcctSchema_ID
	AND (AD_IsOrgIncluded(a.AD_Org_ID, :new.AD_ORG_ID, :new.AD_Client_ID)<>-1
	OR AD_IsOrgIncluded(:new.AD_ORG_ID, a.AD_Org_ID, :new.AD_Client_ID)<>-1)
  ) LOOP
         --  Account
         INSERT INTO M_Product_Acct
             (M_Product_Acct_ID, M_Product_ID, C_AcctSchema_ID,
             AD_Client_ID, AD_Org_ID, IsActive, Created, CreatedBy, Updated, UpdatedBy,
             P_Revenue_Acct, P_Expense_Acct, P_Asset_Acct, P_COGS_Acct,
    P_PurchasePriceVariance_Acct, P_InvoicePriceVariance_Acct,
    P_TradeDiscountRec_Acct, P_TradeDiscountGrant_Acct)
         VALUES
             (get_uuid(), :new.M_Product_ID, Cur_Defaults.C_AcctSchema_ID,
             :new.AD_Client_ID, :new.AD_ORG_ID, 'Y', now(), :new.CreatedBy, now(), :new.UpdatedBy,
             Cur_Defaults.P_Revenue_Acct, Cur_Defaults.P_Expense_Acct, Cur_Defaults.P_Asset_Acct, Cur_Defaults.P_COGS_Acct,
    Cur_Defaults.P_PurchasePriceVariance_Acct, Cur_Defaults.P_InvoicePriceVariance_Acct,
    Cur_Defaults.P_TradeDiscountRec_Acct, Cur_Defaults.P_TradeDiscountGrant_Acct);

   END LOOP;


     --  Create Translation Row
     INSERT INTO M_Product_Trl
         (M_Product_Trl_ID, M_Product_ID, AD_Language, AD_Client_ID, AD_Org_ID,
         IsActive, Created, CreatedBy, Updated, UpdatedBy,
         Name, DocumentNote, IsTranslated)
     SELECT get_uuid(), :new.M_Product_ID, AD_Language, :new.AD_Client_ID, :new.AD_Org_ID,
         :new.IsActive, :new.Created, :new.CreatedBy, :new.Updated, :new.UpdatedBy,
         :new.Name, :new.DocumentNote, 'N'
     FROM    AD_Language
     WHERE IsActive = 'Y' AND IsSystemLanguage = 'Y'
    AND EXISTS (SELECT * FROM AD_Client
     WHERE AD_Client_ID=:new.AD_Client_ID AND IsMultiLingualDocument='Y');


     --  Create TreeNode --
     --  get AD_Tree_ID + ParentID
     SELECT  c.AD_Tree_Product_ID, n.Node_ID INTO v_xTree_ID, v_xParent_ID
     FROM    AD_ClientInfo c, AD_TreeNodePR n
     WHERE   c.AD_Tree_Product_ID=n.AD_Tree_ID
         AND n.Parent_ID IS NULL
         AND c.AD_Client_ID=:new.AD_Client_ID;

     --  DBMS_OUTPUT.PUT_LINE('Tree='||v_xTree_ID||'  Node='||:new.M_Product_ID||'  Parent='||v_xParent_ID);

     --  Insert into TreeNode
     INSERT INTO AD_TreeNodePR
         (AD_TreeNodePR_ID, AD_Client_ID, AD_Org_ID,
         IsActive, Created, CreatedBy, Updated, UpdatedBy,
         AD_Tree_ID, Node_ID,
         Parent_ID, SeqNo)
     VALUES
         (get_uuid(), :new.AD_Client_ID, :new.AD_Org_ID,
         :new.IsActive, :new.Created, :new.CreatedBy, :new.Updated, :new.UpdatedBy,
         v_xTree_ID, :new.M_Product_ID,
         v_xParent_ID, (CASE :new.IsSummary WHEN 'Y' THEN 100 ELSE 999 END));     -- Summary Nodes first
 ELSIF (DELETING) THEN
    DELETE FROM AD_TreeNodePR WHERE AD_Client_ID = :old.AD_Client_ID AND Node_ID = :old.M_Product_ID;
 END IF;
EXCEPTION
 WHEN NO_DATA_FOUND THEN
  RAISE_APPLICATION_ERROR(-20009, 'M_Product InsertTrigger Error: No ClientInfo or parent TreeNode');

END M_PRODUCT_TRG
]]></body>
    </trigger>
  </database>
